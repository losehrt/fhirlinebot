#!/usr/bin/env ruby

require 'date'
require 'json'
require 'optparse'

# é¡è‰²é…ç½®
class Colors
  def self.blue(text); "\e[34m#{text}\e[0m"; end
  def self.green(text); "\e[32m#{text}\e[0m"; end
  def self.yellow(text); "\e[33m#{text}\e[0m"; end
  def self.red(text); "\e[31m#{text}\e[0m"; end
  def self.bold(text); "\e[1m#{text}\e[0m"; end
  def self.dim(text); "\e[2m#{text}\e[0m"; end
end

# ç¨‹å¼ä»£ç¢¼çµ±è¨ˆ
class CodeStats
  # å®šç¾©ç¨‹å¼ç¢¼æª”æ¡ˆé¡å‹
  CODE_EXTENSIONS = {
    'rb' => 'ğŸ”´ Ruby',
    'js' => 'ğŸŸ¨ JavaScript',
    'erb' => 'ğŸ”´ ERB (Rails)',
    'css' => 'ğŸŸ¦ CSS',
    'scss' => 'ğŸŸ¦ SCSS',
    'html' => 'ğŸŸ  HTML',
    'json' => 'âšª JSON',
    'yml' => 'âšª YAML',
    'yaml' => 'âšª YAML',
    'coffee' => 'â˜• CoffeeScript',
    'ts' => 'ğŸŸ¦ TypeScript',
    'tsx' => 'ğŸŸ¦ TypeScript/React',
    'jsx' => 'ğŸŸ¨ JSX',
    'go' => 'ğŸ¹ Go',
    'py' => 'ğŸ Python',
    'java' => 'â˜• Java',
    'cpp' => 'âš™ï¸ C++',
    'c' => 'âš™ï¸ C',
    'h' => 'âš™ï¸ Header',
    'sh' => 'ğŸ”§ Shell',
    'sql' => 'ğŸ—„ï¸ SQL',
  }

  # éç¨‹å¼ç¢¼æª”æ¡ˆé¡å‹
  NON_CODE_EXTENSIONS = {
    'md' => 'Markdown',
    'txt' => 'Text',
    'lock' => 'Lock',
    'gemfile' => 'Gemfile',
    'dockerfile' => 'Docker',
    'xml' => 'XML',
    'svg' => 'SVG',
    'png' => 'PNG',
    'jpg' => 'JPG',
    'gif' => 'GIF',
  }

  def initialize
    @stats = {}
    @code_stats = {}
  end

  def run_git_command(cmd)
    `#{cmd}`.strip
  end

  def collect_daily_stats
    # ä½¿ç”¨ git log --numstat æ›´å¿«é€Ÿåœ°å–å¾—çµ±è¨ˆ
    cmd = "git log --pretty=format:'%ai' --numstat"
    output = run_git_command(cmd)

    lines = output.split("\n")
    current_date = nil

    lines.each do |line|
      # è­˜åˆ¥æ—¥æœŸè¡Œ
      if line.match?(/^\d{4}-\d{2}-\d{2}/)
        current_date = line.split(' ')[0]
        @stats[current_date] ||= { code: 0, non_code: 0, details: {} }
      # è­˜åˆ¥ numstat è¡Œ (additions, deletions, filename)
      elsif line.match?(/^\d+\s+\d+\s+/) && current_date
        parts = line.split("\t")
        next if parts.length < 3

        additions = parts[0].to_i
        filename = parts[2]

        next if should_skip?(filename)

        ext = get_file_extension(filename)
        is_code = CODE_EXTENSIONS.key?(ext)

        # ä½¿ç”¨ additions ä½œç‚ºç¨‹å¼ç¢¼è¡Œæ•¸ï¼ˆæ›´å¿«æ›´æº–ç¢ºï¼‰
        if is_code
          @stats[current_date][:code] += additions
          @stats[current_date][:details][ext] ||= 0
          @stats[current_date][:details][ext] += additions
        else
          @stats[current_date][:non_code] += additions
        end
      end
    end
  end

  def get_file_extension(filename)
    ext = File.extname(filename).sub(/^\./, '').downcase
    ext.empty? ? 'no-ext' : ext
  end

  def should_skip?(filename)
    skip_patterns = [
      /node_modules/,
      /\.bundle/,
      /vendor\/bundle/,
      /\.lock$/,
      /\.DS_Store/,
      /\.log$/,
      /^test\//,
      /^spec\//,
      /\.min\./,
    ]

    skip_patterns.any? { |pattern| filename.match?(pattern) }
  end

  def print_table
    return puts "âŒ æ²’æœ‰æ‰¾åˆ° Git çµ±è¨ˆè³‡è¨Š" if @stats.empty?

    sorted_dates = @stats.keys.sort

    # è¨ˆç®—ç¸½çµ±è¨ˆ
    total_code = @stats.values.sum { |v| v[:code] }
    total_non_code = @stats.values.sum { |v| v[:non_code] }
    total_all = total_code + total_non_code

    # è¡¨é ­
    puts "\n"
    puts Colors.bold("ğŸ’» æ¯æ—¥ç¨‹å¼ç¢¼è¡Œæ•¸çµ±è¨ˆ")
    puts Colors.dim("=" * 100)

    # è¡¨æ ¼é ­éƒ¨
    printf "%-12s | %12s | %12s | %12s | %10s | %20s\n",
           Colors.bold("æ—¥æœŸ"),
           Colors.bold("ğŸ’» ç¨‹å¼ç¢¼"),
           Colors.bold("ğŸ“„ å…¶ä»–æª”æ¡ˆ"),
           Colors.bold("ğŸ“Š ç¸½è¨ˆ"),
           Colors.bold("ä»£ç¢¼ä½”æ¯”"),
           Colors.bold("ä¸»è¦èªè¨€")

    puts Colors.dim("-" * 100)

    # è¡¨æ ¼å…§å®¹
    sorted_dates.each do |date|
      stats = @stats[date]
      code = stats[:code]
      non_code = stats[:non_code]
      total = code + non_code
      ratio = total > 0 ? ((code.to_f / total) * 100).round(1) : 0

      # å–ä¸»è¦èªè¨€
      top_lang = stats[:details]
        .sort_by { |_, v| v }
        .reverse
        .first(2)
        .map { |ext, lines| "#{CODE_EXTENSIONS[ext] || ext}(#{lines})" }
        .join(", ")

      printf "%-12s | %12s | %12s | %12s | %10s | %-20s\n",
             Colors.blue(date),
             Colors.green("#{code}"),
             Colors.yellow("#{non_code}"),
             "#{total}",
             "#{ratio}%",
             top_lang[0..19]
    end

    # è¡¨å°¾
    puts Colors.dim("-" * 100)

    # çµ±è¨ˆæ‘˜è¦
    total_ratio = total_all > 0 ? ((total_code.to_f / total_all) * 100).round(1) : 0
    printf "%-12s | %12s | %12s | %12s | %10s\n",
           Colors.bold("ç¸½è¨ˆ"),
           Colors.green("#{total_code}"),
           Colors.yellow("#{total_non_code}"),
           Colors.bold("#{total_all}"),
           Colors.bold("#{total_ratio}%")

    puts Colors.dim("=" * 100)

    # é¡å¤–çµ±è¨ˆè³‡è¨Š
    puts "\nğŸ“ˆ é¡å¤–çµ±è¨ˆï¼š"
    puts "  â€¢ çµ±è¨ˆå¤©æ•¸ï¼š#{sorted_dates.length} å¤©"
    puts "  â€¢ æ¯æ—¥å¹³å‡ç¨‹å¼ç¢¼ï¼š#{(total_code / sorted_dates.length).round} è¡Œ"
    puts "  â€¢ ç¸½ç¨‹å¼ç¢¼è¡Œæ•¸ï¼š#{Colors.green(total_code.to_s)} è¡Œ"
    puts "  â€¢ ç¨‹å¼ç¢¼ä½”æ¯”ï¼š#{Colors.green("#{total_ratio}%")}"

    # èªè¨€é¡å‹çµ±è¨ˆ
    puts "\nğŸ—£ï¸ æŒ‰èªè¨€çµ±è¨ˆï¼š"
    all_langs = {}
    @stats.values.each do |stat|
      stat[:details].each do |ext, lines|
        all_langs[ext] ||= 0
        all_langs[ext] += lines
      end
    end

    all_langs
      .sort_by { |_, v| v }
      .reverse
      .first(8)
      .each do |ext, lines|
        percentage = total_code > 0 ? ((lines.to_f / total_code) * 100).round(1) : 0
        lang_name = CODE_EXTENSIONS[ext] || ext
        bar = "â–“" * (percentage / 2).round + "â–‘" * ((100 - percentage) / 2).round
        printf "  %s %-20s: %5d è¡Œ (%.1f%%) %s\n",
               lang_name[0..0],
               lang_name,
               lines,
               percentage,
               bar
      end

    puts ""
  end

  def print_chart
    return puts "âŒ æ²’æœ‰æ‰¾åˆ° Git çµ±è¨ˆè³‡è¨Š" if @stats.empty?

    sorted_dates = @stats.keys.sort
    max_code = @stats.values.map { |v| v[:code] }.max

    puts "\n"
    puts Colors.bold("ğŸ“Š ç¨‹å¼ç¢¼è¡Œæ•¸è¶¨å‹¢åœ–")
    puts Colors.dim("=" * 80)

    sorted_dates.each do |date|
      code = @stats[date][:code]
      ratio = max_code > 0 ? (code.to_f / max_code * 30).round : 0

      bar = "â–ˆ" * ratio + "â–‘" * (30 - ratio)
      printf "%s | %s | %6d è¡Œ\n",
             Colors.blue(date),
             Colors.green(bar),
             code
    end

    puts Colors.dim("=" * 80)
    puts "  â–ˆ = ç¨‹å¼ç¢¼è¡Œæ•¸  â–‘ = ç©ºç™½"
    puts ""
  end
end

# å‘½ä»¤è¡Œé¸é …
options = {}
OptionParser.new do |opts|
  opts.banner = "ä½¿ç”¨æ–¹å¼: bin/code-stats [é¸é …]"

  opts.on("-d", "--days N", Integer, "åªçµ±è¨ˆéå» N å¤©") do |n|
    options[:days] = n
  end

  opts.on("-c", "--chart", "é¡¯ç¤ºåœ–è¡¨") do
    options[:chart] = true
  end

  opts.on("-h", "--help", "é¡¯ç¤ºå¹«åŠ©") do
    puts opts
    exit
  end
end.parse!

# åŸ·è¡Œ
stats = CodeStats.new
stats.collect_daily_stats

# å¦‚æœæŒ‡å®šäº†å¤©æ•¸ï¼Œå‰‡ç¯©é¸
if options[:days]
  cutoff_date = (Date.today - options[:days]).to_s
  stats.instance_variable_get(:@stats).reject! { |date, _| date < cutoff_date }
end

stats.print_table

if options[:chart]
  stats.print_chart
end
